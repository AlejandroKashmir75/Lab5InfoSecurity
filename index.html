<!doctype html>
<html>
  <head>
    <title>Chat Socket.IO UNA</title>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { font: 13px Helvetica, Arial; }
      form { background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; }
      form input { border: 0; padding: 10px;}
      form button { width: 10%; background: rgb(130, 224, 255);  border: none; padding: 10px; }
      #messages { list-style-type: none; margin: 0; padding: 0; }
      #messages li { padding: 5px 10px; }
      #messages li:nth-child(odd) { background: #eee; }
      #messages { margin-bottom: 40px }
      #nombre, #m { display: inline-block;}
      #m {width: 69%; margin-right: 4px;}
      #nombre {width: 20%}
      .chat-item img { max-width: 400px; max-height: 400px; display:block; margin-top:5px; }
      .chat-item iframe { display:block; margin-top:5px; max-width:100%; }
    </style>
  </head>
  <body>
    <ul id="messages"></ul>
    <form action="">
      <input id="nombre" autocomplete="off" placeholder="Username"/>
      <input id="m" autocomplete="off" placeholder="Escriba un mensaje" /><button>Send</button>
    </form>
    <script src="https://cdn.socket.io/4.7.2/socket.io.js"></script>
    <script src="https://code.jquery.com/jquery-1.11.1.js"></script>
    <script>

    var colorHexTxt = "";

    // genera colores aleatorios en hexadeximal
    function getRandomColor() {
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
          color += letters[Math.floor(Math.random() * 16)];
        }

        return color;
     }

     // Fallback helpers (si el servidor no devuelve tipo)
     function looksLikeImageUrl(url) {
       return typeof url === 'string' && url.match(/\.(jpg|jpeg|png|gif|bmp)(?:[?#].*)?$/i);
     }

     function getYouTubeEmbedFromUrl(url) {
       if (typeof url !== 'string') return null;
       // soporta youtu.be/ID y youtube.com/watch?v=ID
       var m = url.match(/(?:youtu\.be\/|v=|\/embed\/)([A-Za-z0-9_-]{11})/);
       return m ? ('https://www.youtube.com/embed/' + m[1]) : null;
     }

      $(function () {
        var socket = io();

        // emite evento al servidor
        $('form').submit(function(){
            var nombreTxt = $('#nombre').val() || "Anomimo";
            var mensajeTxt = $('#m').val();

            if (colorHexTxt == "") {
                colorHexTxt = getRandomColor();
            }

            var jsonMsg = { nombre: nombreTxt, mensaje: mensajeTxt, color: colorHexTxt };

            // Enviamos OBJETO (no string). La librería en el servidor acepta ambos.
            socket.emit('Evento-Mensaje-Server', jsonMsg);

            $('#m').val('');
            return false;
        });

        // Recepción: ahora el servidor idealmente envía un OBJETO { nombre, color, mensaje, tipo, original, timestamp, from }
        socket.on('Evento-Mensaje-Server', function(payload){
            // Debug: evitar imprimir payload completo (contiene original que puede ser malicioso)
            // Mostrar solo campos seguros para depuración.
            try {
              console.log('payload recibido (safe):', { nombre: payload.nombre, tipo: payload.tipo, timestamp: payload.timestamp });
            } catch (e) { /* ignore */ }

            // payload puede ser string en algunos setups; intentar parsear
            if (typeof payload === 'string') {
              try { payload = JSON.parse(payload); }
              catch(e) { /* si no es JSON, lo tratamos como texto */ }
            }
            if (!payload) return;

            // Crear elemento <li> de forma segura (sin innerHTML)
            var $li = $('<li>').addClass('chat-item');

            // Nombre / color
            var nombre = payload.nombre || "Anomimo";
            var color = payload.color || "#000";
            var $bold = $('<b>').css('color', color).text(nombre + ': ');
            $li.append($bold);

            // Determinar tipo (servidor preferencia). Si no existe, hacer fallback en cliente.
            var tipo = payload.tipo || 'text';
            var contenidoUrl = payload.mensaje;

            // Fallback detection si tipo no fue enviado o no es confiable
            if (!payload.tipo || payload.tipo === 'text') {
              // si parece imagen, renderizar imagen
              if (looksLikeImageUrl(contenidoUrl)) {
                tipo = 'image';
              } else {
                // si es youtube, generar embed
                var embed = getYouTubeEmbedFromUrl(contenidoUrl);
                if (embed) {
                  tipo = 'video';
                  contenidoUrl = embed; // usar embed para iframe
                }
              }
            }

            if (tipo === 'image') {
                // payload.mensaje debe ser la URL validada de la imagen o el original
                var $img = $('<img>').attr('src', contenidoUrl).attr('alt', 'Imagen enviada');
                $li.append($img);
            } else if (tipo === 'video') {
                // payload.mensaje preferiblemente es la URL embed (https://www.youtube.com/embed/ID)
                // si servidor envió un video "no embed", getYouTubeEmbedFromUrl ya lo convirtió
                var $iframe = $('<iframe>')
                  .attr('width', 560)
                  .attr('height', 315)
                  .attr('src', contenidoUrl)
                  .attr('frameborder', 0)
                  .attr('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture')
                  .attr('allowfullscreen', 'true');
                $li.append($iframe);
            } else {
                // Texto: payload.mensaje ya viene escapado por el servidor idealmente.
                // Aun así, usamos text() para evitar inyección.
                var $p = $('<span>').text(payload.mensaje);
                $li.append($p);
            }

            // metadata (timestamp / from)
            var ts = payload.timestamp ? new Date(payload.timestamp) : new Date();
            var metaText = ' ' + ts.toLocaleTimeString();
            if (payload.from) metaText += ' — ' + payload.from;
            var $meta = $('<small>').text(metaText);
            $li.append($meta);

            $('#messages').append($li);
            // scrollear
            window.scrollTo(0, document.body.scrollHeight);
        });

      });
    </script>
  </body>
</html>
